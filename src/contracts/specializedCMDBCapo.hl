module specializedCapo

// exports a Datum and Redeemer.  
//! the Datum and Redeemer of specializations
//  MUST include the same enum variants as in this
//  unspecialized version.  if you're specializing 
//  ... and you get a Helios compiler error,
// ... these are the first things you should check!
//! Your specialization MAY include any 
// ... additional functions, imports or methods

import { 
    RelativeDelegateLink,
    requiresValidDelegateOutput
} from CapoDelegateHelpers


import {
    mkTv,
    tvCharter
} from StellarHeliosHelpers

import {
    getOutputForInput,
    outputDatum
} from StellarHeliosHelpers

struct BookEntryStruct {
    entryType: String
    title: String
    content: String
    createdAt: Int
    updatedAt: Int
    expiresAt: Int
    //  suggestedBy: String // XXX collaborator-id  - see delegation-link, whose content serves the same purpose.
    changeParentEntry: String // id of parent obj
    changeParentTxn: Option[TxId] // -> txid
}

// struct LocalCapoConfig {
//     openCreate: Bool "@opn"
//     openSuggestion: Bool "@osg"
//     
// }

enum Datum {
    CharterToken {
        govAuthorityLink: RelativeDelegateLink 
        mintDelegateLink: RelativeDelegateLink 
        // config: LocalCapoConfig
    }
    BookEntry {
        ownerAuthority: RelativeDelegateLink
        entry: BookEntryStruct
    }

    //! datum-validation only supports checks of absolute spendability, 
    //  ... and can't check details of the Activity/Redeemer being used.
    func validateSpend(self, ctx: ScriptContext, mph : MintingPolicyHash) -> Bool {
        true ||
        ( 
            self.serialize() /* never */ == ctx.serialize() ||
            mph.serialize() /* never */ == ctx.serialize()  
        )
    } 

    func validateEntry(self, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool{
        self.switch{
            BookEntry{_, entry} => {
                needsLength : (String, String, Int) -> () = (v : String, fn : String, min : Int) -> {
                    assert(v.encode_utf8().length >= min,
                        "field length error" // + ": " + fn + " needs " +min.show() + " chars or more"
                    )
                };

                goodTypes = Map[String]Bool{
                    "pg":true, //page
                    "spg": true,  // suggested page
                    "chg": true  // suggested change
                };
                assert(goodTypes.get_safe(entry.entryType).switch{
                    None => {
                        error("invalid entryType: '"+ entry.entryType + "'")
                    },
                    _ => true
                }, ""); // already failed as invalid ^^

                validatesOk : Bool = if ("chg" == entry.entryType) {
                    assert(
                        entry.title.encode_utf8().length >0 || 
                        entry.content.encode_utf8().length > 0,
                         "either title or content must change"
                    );
                    peLength: Int = entry.changeParentEntry.encode_utf8().length;
                    assert(
                        peLength > 15, 
                        "changeParent entry too short: "+peLength.show()
                    );

                    // the value of the id-token:
                    parentRec : Value = mkTv(mph, entry.changeParentEntry);

                    entry.changeParentTxn.switch {
                        Some{txid} => {
                            ctx.tx.ref_inputs.find_safe((txin: TxInput) -> {
                                txin.output_id.tx_id == txid &&
                                txin.output.value >= parentRec
                            }).switch{
                                Some => true,
                                None => error("no ref_input matching changeParentTxn, changeParentEntry")
                            }
                        },
                        _ => error("missing required changeParentTxn")
                    }        
                } else {
                    needsLength(entry.title, "title", 10);
                    needsLength(entry.content, "content", 40);

                    true    
                };
                
                validatesOk
            },
            _ => error("wrong datum type")//"validateEntry only works on BookEntry datum")
        }
    }

    func txnHasUpdateAuthority(self, ownerAuthority: RelativeDelegateLink, oldListing: BookEntryStruct, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        self.switch{
            BookEntry{newOwnerAuthority, bookEntry} => {
        
                // hasCollabToken : Bool = (
                //     ownerAuthority.uutName.starts_with("collab-") &&
                //     requiresValidDelegateOutput(ownerAuthority, mph, ctx)
                // );

                needsEditorForActivity : Option[String] = 
                    //! if the entryType is changing to "pg", requires editor authority.
                    if (oldListing.entryType == "spg" && bookEntry.entryType == "pg") { 
                        Option[String]::Some{"change from spg to pg"}
                    } else {
                    //! if the owner is changing, requires editor authority 
                    if (ownerAuthority.uutName != newOwnerAuthority.uutName) { 
                        //   !!! TODO: ... and ref-input to new owner-UUT.

                            Option[String]::Some{"change ownership"}
                        } else { Option[String]::None }
                    };

                charterData : Option[Datum::CharterToken] = self.hasCharterRefInput(ctx, mph);

                availableAuthority : RelativeDelegateLink = charterData.switch{
                    Some{Datum::CharterToken{govAuthority, _}} => {
                        print("using editor's govAuthority for doc update");
                        govAuthority
                    },
                    None => {
                        needsEditorForActivity.switch{
                            Some{activity} => error("update: insufficient authority for "+activity),
                            None => {
                                print("no charter-ref; requiring document-owner authority for doc update");
                                ownerAuthority
                            }
                        }
                    }
                };
                hasSufficientAuthority : Bool = requiresValidDelegateOutput(availableAuthority, mph, ctx);

                hasSufficientAuthority
            }, 
            _ => error("wrong datum type")//"txnHasUpdateAuthority only works on BookEntry datum")
        } || (
            self.serialize() /* never */ == ctx.serialize() &&
            self.serialize() /* never */ == mph.serialize()
        )
    }

    func txnHasCreateAuthority(self, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        self.switch{
            BookEntry{entryOwnerAuthority, bookEntry} => {

                //! creating any entry needs a collab- token
                hasCollabToken : Bool = (
                    entryOwnerAuthority.uutName.starts_with("collab-") &&
                    requiresValidDelegateOutput(entryOwnerAuthority, mph, ctx)
                );
                print("bookEntry.entryType is " + bookEntry.entryType);

                //! creating a Page needs Editor authority
                hasAuthorityForEntryType : Bool = if (bookEntry.entryType == "pg") {
                    charterData : Option[Datum::CharterToken] = self.hasCharterRefInput(ctx, mph);
                    charterData.switch{
                        Some{Datum::CharterToken{govAuthority, _}} => {
                            print("using editor's govAuthority for doc update");
                            requiresValidDelegateOutput(govAuthority, mph, ctx)
                        },
                        _ => error("insufficient authority to create entryType=pg")
                    }
                } else { hasCollabToken };

                hasCollabToken && hasAuthorityForEntryType
            },
            _ => error("no create authority on non-book-entry")
        } || (
            self.serialize() /* never */ == ctx.serialize()
        )
    }

    func hasCharterRefInput(
        self,
        ctx: ScriptContext, 
        mph : MintingPolicyHash
    ) -> Option[Datum::CharterToken] {
        chVal : Value = tvCharter(mph);
        hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };

        assert(
            self.serialize() != ctx.serialize() &&
            self.serialize() != mph.serialize(), "never thrown"
        );

        ctx.tx.ref_inputs.find_safe(hasCharter).switch{
            Some{txin} => Option[Datum::CharterToken]::Some{
                Datum::from_data( 
                    txin.datum.get_inline_data() 
                ).switch{
                    c : CharterToken => c,
                    _ => error("wrong enum")
                }
            },
            None => Option[Datum::CharterToken]::None
        }
    }
    
}
func hasCharterRefInput(
    ctx: ScriptContext, 
    mph : MintingPolicyHash
) -> Option[Datum::CharterToken] {
    chVal : Value = tvCharter(mph);
    hasCharter = (txin : TxInput) -> Bool { txin.value.contains(chVal) };
    
    ctx.tx.ref_inputs.find_safe(hasCharter).switch{
        Some{txin} => Option[Datum::CharterToken]::Some{
            Datum::from_data( 
                txin.datum.get_inline_data() 
            ).switch{
                c : CharterToken => c,
                _ => error("wrong enum")
            }
        },
        None => Option[Datum::CharterToken]::None
    }
}
enum Activity {
    // standard redeemer types:
    spendingDatum
    updatingCharter    
    usingAuthority

    //custom redeemer types:
    // registeringEntry can't be from this script unless there's a spend
    updatingEntry
    retiringEntry

       func allowRetiringEntry(self, datum: Datum, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        // rc -> if is severely outdated, burn the UUT and allow minUtxo recovery
        false && ( 
            self.serialize() /* never */ == datum.serialize()  ||
            self.serialize() /* never */ == mph.serialize()  ||
            self.serialize() /* never */ == ctx.serialize() 
        )
    }

    func allowUpdatingEntry(self, ownerAuthority: RelativeDelegateLink, oldListing: BookEntryStruct, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        txnTime : TimeRange = ctx.tx.time_range;        
        newTxo : TxOutput = getOutputForInput(ctx, ctx.get_current_input());
        // already checked by getOutputForInput()
        // assert(newTxo.value.get_assets().to_map().length == 1, "invalid token bundle with various assets");
        // assert(newTxo.value.get_policy(mph).length == 1, "invalid with multiple tokens in the utxo");

        //!!! todo: require charterDatum in refUtxo (if expected editing delegate not there)
        //    OR - require delegate as below if charterDatum is not found in refUtxo
        // if not using editing delegate, require charterAuth instead
     
        newDatum : Datum = outputDatum[Datum](newTxo);
        Datum::BookEntry{newAuthority, newListing} = newDatum;
        assert(newAuthority == ownerAuthority, "authority change invalid");

        // createdAt: Int
        assert(newListing.createdAt == oldListing.createdAt, "createdAt must not be modified");
        // updatedAt: Int
        assert(txnTime.contains(Time::new(newListing.updatedAt)), "incorrect updatedAt");
        // expiresAt: Int
        assert(Time::new(newListing.expiresAt) < Time::new(newListing.updatedAt) + (365 * Duration::DAY),
            "expiry must be less than 1y"
        );
        // lastExpiredAt: Int
    
        datumCanUpdate : Bool = newDatum.txnHasUpdateAuthority(ownerAuthority, oldListing, ctx, mph);
        assert(datumCanUpdate, "no update authority in txn");

        // charterData : Option[Datum::CharterToken] = hasCharterRefInput(ctx, mph);
        // availableAuthority : RelativeDelegateLink = charterData.switch{
        //     Some{Datum::CharterToken{govAuthority, _}} => {
        //         print("using editor's govAuthority for doc update");
        //         govAuthority
        //     },
        //     None => {
        //         print("no charter-ref; requiring document-owner authority for doc update");
        //         ownerAuthority
        //     }
        // };
        // hasSufficientAuthority : Bool = requiresValidDelegateOutput(availableAuthority, mph, ctx);

        ( 
            datumCanUpdate  &&
            newDatum.validateEntry(ctx, mph) 
        ) ||
        ( 
            ( self.serialize() /* never */ == oldListing.serialize() )  ||
            (  self.serialize() /* never */ == ctx.serialize()  )
        )
    }

    func allowActivity(self, datum: Datum, ctx: ScriptContext, mph: MintingPolicyHash) -> Bool {
        //! Note: an overridden Reedeemer def doesn't have to replicate the checks
        // ... for the baseline enum variants; it's not called in those cases.

        txnTime : TimeRange = ctx.tx.time_range;        
        assert(/* ✅ limited txn validity */ 
            (txnTime.end - txnTime.start) < 1 * Duration::HOUR, 
            "bad validity"
            // + ": validity period must be less than 1h"); 
        );

        datum.switch{
            BookEntry{ownerAuthority, entry} => {
                self.switch{
                    updatingEntry => self.allowUpdatingEntry(ownerAuthority, entry, ctx, mph),
                    retiringEntry => self.allowRetiringEntry(datum, ctx, mph),
                    // registeringEntry => assert(false, "unreachable code"),
                    _ => error("unreachable code")
                }
               // not executed, but prevents the args from showing up as unused:
                || ( ownerAuthority.serialize() != entry.serialize() )
            },
            _ => error("unhandled datum type")
            // not executed, but prevents the args from showing up as unused:
        } || ( ctx.tx.serialize() /* never */ == datum.serialize() )
    }
}

struct typeInfo {
    bookEntryStruct: BookEntryStruct
    datum: Datum
    redeemers: Activity
}
const types : typeInfo = typeInfo {
    BookEntryStruct::from_data(Data{}),
    Datum::from_data(Data{}),
    Activity::from_data(Data{})
}